package com.kapoue.opecours.data.repository

import com.kapoue.opecours.data.local.StockDao
import com.kapoue.opecours.data.mapper.toDomain
import com.kapoue.opecours.data.mapper.toEntity
import com.kapoue.opecours.data.remote.dto.AlphaVantageMapper
import com.kapoue.opecours.data.mock.MockStockData
import com.kapoue.opecours.data.remote.AlphaVantageApi
import com.kapoue.opecours.domain.model.Operator
import com.kapoue.opecours.domain.model.Stock
import com.kapoue.opecours.util.Constants
import com.kapoue.opecours.util.DebugUtils
import com.kapoue.opecours.util.NetworkUtils
import com.kapoue.opecours.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import retrofit2.HttpException
import java.io.IOException
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class StockRepository @Inject constructor(
    private val api: AlphaVantageApi,
    private val dao: StockDao,
    private val networkUtils: NetworkUtils
) {
    fun getStocks(): Flow<Resource<List<Stock>>> = flow {
        DebugUtils.logInfo("D√©but de getStocks()")
        emit(Resource.Loading())
        
        // √âmettre les donn√©es en cache d'abord
        try {
            val cachedStocks = dao.getAllStocks().first().map { it.toDomain() }
            DebugUtils.logInfo("Donn√©es en cache trouv√©es: ${cachedStocks.size} stocks")
            if (cachedStocks.isNotEmpty()) {
                emit(Resource.Success(cachedStocks))
            }
        } catch (e: Exception) {
            DebugUtils.logError("Erreur lors de la lecture du cache", e)
        }
        
        // Puis tenter de rafra√Æchir depuis l'API
        if (networkUtils.isNetworkAvailable()) {
            DebugUtils.logInfo("R√©seau disponible, tentative d'appel API")
            try {
                val stocks = fetchFromApi()
                DebugUtils.logInfo("API appel√©e avec succ√®s, ${stocks.size} stocks r√©cup√©r√©s")
                dao.insertAll(stocks.map { it.toEntity() })
                emit(Resource.Success(stocks))
            } catch (e: HttpException) {
                val errorMsg = "Erreur serveur (${e.code()}): ${e.message()}"
                DebugUtils.logError(errorMsg, e)
                emit(Resource.Error(errorMsg))
            } catch (e: IOException) {
                DebugUtils.logError("Erreur de connexion Internet", e)
                emit(Resource.Error("Erreur de connexion Internet"))
            } catch (e: Exception) {
                val errorMsg = "Erreur lors de la r√©cup√©ration des donn√©es: ${e.message}"
                DebugUtils.logError(errorMsg, e)
                emit(Resource.Error(errorMsg))
            }
        } else {
            DebugUtils.logInfo("Pas de r√©seau disponible")
            try {
                val cachedStocks = dao.getAllStocks().first().map { it.toDomain() }
                if (cachedStocks.isEmpty()) {
                    emit(Resource.Error("Pas de connexion Internet et aucune donn√©e en cache"))
                }
            } catch (e: Exception) {
                emit(Resource.Error("Pas de connexion Internet"))
            }
        }
    }
    
    private suspend fun fetchFromApi(): List<Stock> {
        DebugUtils.logInfo("üîÑ D√©but de fetchFromApi() avec Alpha Vantage")
        DebugUtils.logInfo("üîë Cl√© API utilis√©e: ${Constants.API_KEY}")
        DebugUtils.logInfo("üåê URL de base: ${Constants.BASE_URL}")
        
        return try {
            val activeOperators = Operator.values().filter { it.isActive }
            DebugUtils.logInfo("üìä Op√©rateurs actifs: ${activeOperators.map { it.displayName }}")
            
            activeOperators.map { operator ->
                DebugUtils.logInfo("üìû Appel Alpha Vantage pour ${operator.displayName} (${operator.symbol})")
                val response = api.getQuote(
                    symbol = operator.symbol,
                    apiKey = Constants.API_KEY
                )
                DebugUtils.logInfo("üì° R√©ponse HTTP ${response.code()} pour ${operator.displayName}")
                
                if (response.isSuccessful) {
                    val body = response.body()
                    DebugUtils.logInfo("üì¶ Body re√ßu pour ${operator.displayName}: ${body?.toString()?.take(200)}...")
                    
                    val stockData = body?.let { AlphaVantageMapper.toStock(it, operator) }
                        ?: throw Exception("Donn√©es invalides pour ${operator.displayName}")
                    DebugUtils.logInfo("‚úÖ Donn√©es Alpha Vantage r√©cup√©r√©es pour ${operator.displayName}: ${stockData.currentPrice}‚Ç¨")
                    stockData
                } else {
                    val errorBody = response.errorBody()?.string()
                    DebugUtils.logError("‚ùå Erreur HTTP ${response.code()} pour ${operator.displayName}: $errorBody")
                    throw HttpException(response)
                }
            }
        } catch (e: Exception) {
            DebugUtils.logError("üí• √âchec de l'API Alpha Vantage", e)
            
            if (Constants.USE_MOCK_DATA_FALLBACK) {
                DebugUtils.logInfo("üé≠ Fallback vers donn√©es mock activ√©")
                val mockStocks = MockStockData.getMockStocks().filter { stock ->
                    Operator.values().find { it.symbol == stock.symbol }?.isActive == true
                }
                DebugUtils.logInfo("üìà Donn√©es mock g√©n√©r√©es: ${mockStocks.map { "${it.operatorName}: ${it.currentPrice}‚Ç¨" }}")
                mockStocks
            } else {
                DebugUtils.logError("‚ùå Fallback vers donn√©es mock d√©sactiv√© - propagation de l'erreur")
                throw e
            }
        }
    }
    
    suspend fun refreshStocks(): Resource<List<Stock>> {
        return try {
            if (!networkUtils.isNetworkAvailable()) {
                DebugUtils.logInfo("‚ùå Pas de r√©seau disponible")
                if (Constants.USE_MOCK_DATA_FALLBACK) {
                    DebugUtils.logInfo("üé≠ Utilisation des donn√©es mock (pas de r√©seau)")
                    val mockStocks = MockStockData.getMockStocks()
                    dao.insertAll(mockStocks.map { it.toEntity() })
                    return Resource.Success(mockStocks)
                } else {
                    return Resource.Error("Pas de connexion Internet")
                }
            }
            
            val stocks = fetchFromApi()
            dao.insertAll(stocks.map { it.toEntity() })
            Resource.Success(stocks)
        } catch (e: HttpException) {
            val errorMsg = "Erreur serveur (${e.code()}): ${e.message()}"
            DebugUtils.logError(errorMsg, e)
            if (Constants.USE_MOCK_DATA_FALLBACK) {
                DebugUtils.logInfo("üé≠ Fallback vers donn√©es mock (erreur HTTP)")
                val mockStocks = MockStockData.getMockStocks()
                dao.insertAll(mockStocks.map { it.toEntity() })
                Resource.Success(mockStocks)
            } else {
                Resource.Error(errorMsg)
            }
        } catch (e: IOException) {
            val errorMsg = "Erreur de connexion Internet"
            DebugUtils.logError(errorMsg, e)
            if (Constants.USE_MOCK_DATA_FALLBACK) {
                DebugUtils.logInfo("üé≠ Fallback vers donn√©es mock (erreur IO)")
                val mockStocks = MockStockData.getMockStocks()
                dao.insertAll(mockStocks.map { it.toEntity() })
                Resource.Success(mockStocks)
            } else {
                Resource.Error(errorMsg)
            }
        } catch (e: Exception) {
            val errorMsg = "Erreur lors de la r√©cup√©ration des donn√©es: ${e.message}"
            DebugUtils.logError(errorMsg, e)
            if (Constants.USE_MOCK_DATA_FALLBACK) {
                DebugUtils.logInfo("üé≠ Fallback vers donn√©es mock (erreur g√©n√©rale)")
                val mockStocks = MockStockData.getMockStocks()
                dao.insertAll(mockStocks.map { it.toEntity() })
                Resource.Success(mockStocks)
            } else {
                Resource.Error(errorMsg)
            }
        }
    }
}